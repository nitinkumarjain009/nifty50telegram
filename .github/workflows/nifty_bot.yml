#!/usr/bin/env python3
import sys
import os
import logging
import datetime
import numpy as np
import subprocess
import importlib.util

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Check and install required packages
required_packages = ['requests', 'pandas', 'beautifulsoup4', 'pandas_ta']

for package in required_packages:
    try:
        if package == 'pandas_ta':
            # Check if pandas_ta is installed
            if importlib.util.find_spec("pandas_ta") is None:
                logger.info(f"Installing {package}...")
                subprocess.check_call([sys.executable, "-m", "pip", "install", package])
                logger.info(f"{package} installed successfully.")
            else:
                logger.info(f"{package} is already installed.")
        else:
            # For other packages, just import to check
            __import__(package)
    except (ImportError, subprocess.CalledProcessError) as e:
        logger.error(f"Error installing {package}: {str(e)}")
        logger.info(f"Attempting to install {package}...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
            logger.info(f"{package} installed successfully.")
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to install {package}: {str(e)}")
            sys.exit(1)

# Import packages (after ensuring they're installed)
import requests
import pandas as pd
from bs4 import BeautifulSoup
import pandas_ta as ta

# Telegram configuration - using environment variables for security with fallback to hardcoded values
# WARNING: Hardcoded fallback API key is a security risk. Use environment variables.
API_KEY = os.environ.get("TELEGRAM_API_KEY", "8017759392:AAEwM-W-y83lLXTjlPl8sC_aBmizuIrFXnU")
CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID", "@stockniftybot")  # Using channel username
BASE_URL = f"https://api.telegram.org/bot{API_KEY}"

# Function to debug Telegram connection
def debug_telegram_connection():
    try:
        # Get bot info to check if token is valid
        test_url = f"{BASE_URL}/getMe"
        response = requests.get(test_url)
        if response.status_code == 200:
            bot_info = response.json()
            logger.info(f"Bot connection successful. Bot name: {bot_info['result']['first_name']}")
        else:
            logger.error(f"Bot connection failed: {response.text}")

        # Test channel posting permission
        test_message = "Testing bot permissions in this channel."
        send_telegram_message(test_message)

    except Exception as e:
        logger.error(f"Debug test failed: {str(e)}")

# Function to send message to Telegram channel
def send_telegram_message(text):
    url = f"{BASE_URL}/sendMessage"
    payload = {
        "chat_id": CHAT_ID,  # Using channel username: @stockniftybot
        "text": text,
        "parse_mode": "Markdown"
    }

    try:
        response = requests.post(url, data=payload)
        if response.status_code == 200:
            logger.info(f"Message sent successfully to {CHAT_ID}")
        else:
            error_info = response.json() if response.text else "No error details"
            logger.error(f"Failed to send message: {error_info}")
    except Exception as e:
        logger.error(f"Error sending message: {str(e)}")

# Function to get historical price data for RSI calculation (SIMULATED DATA)
def get_historical_data(symbol, timeframe='1M'):
    try:
        # In real implementation, this would fetch data from an API
        # For now, generating sample data
        end_date = datetime.datetime.now()

        # Determine date range based on timeframe
        if timeframe == '1M':
            # Monthly data - 24 months
            start_date = end_date - datetime.timedelta(days=730)
            periods = 24
        else:  # '1W'
            # Weekly data - 52 weeks
            start_date = end_date - datetime.timedelta(days=365)
            periods = 52

        date_range = pd.date_range(start=start_date, end=end_date, periods=periods)

        # Generate sample data based on symbol hash for consistency
        np.random.seed(sum(ord(c) for
